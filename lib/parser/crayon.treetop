require 'parser/nodes'
require 'parser/object_types'
require 'parser/control_flow'
require 'parser/functions'

module Crayon
  module Parser

    grammar Crayon
      include ObjectTypes
      include ControlFlow
      include Functions

      rule script
        expression remaining_expressions:(newline expression)* newline <Script>
        {
          def expressions
            [expression] + remaining_expressions.elements.map {|e| e.expression}
          end
        }
      end

      rule expression
        spaced_statements:(space statement)+ space <Expression>
        {
          def statements
            spaced_statements.elements.map {|e| e.statement}
          end
        }
      end

      rule statement
        assignment / conditional / loop / comparison / function / call / equation / object / comment
      end

      rule object
        var / number / string / list / boolean
      end

      rule comparison
        object space op:("=" / "≠" / ">" / "<" / "≥" / "≤" / "and" / "or") space expression
      end

      rule conditional
        "if" space condition:expression space newline
          body:(expression space newline)* 
        "end"
      end

      rule call
        function:var space arglist <Call>
      end

      rule arglist
        default_arg:expression? space "with" space arg:argument remaining_args:(space "," space arg:argument)* <Arglist> 
        {
          def args
            args = {arg.var => arg.expression}
            args.merge!({"__default" => default_arg}) if defined? default_arg
            remaining_args.elements.each {|e| args.merge!({e.arg.var => e.arg.expression})}
            args
          end
        } /
        default_arg:expression? space "with" space newline 
          arg:argument
          remaining_args:(space newline arg:argument)* newline 
        "end" <Arglist> 
        {
          def args
            args = {arg.var => arg.expression}
            args.merge!({"__default" => default_arg}) if defined? default_arg
            remaining_args.elements.each {|e| args.merge!({e.arg.var => e.arg.expression})}
            args
          end
        } /
        default_arg:expression space <Arglist>
        {
          def args
            {"__default" => default_arg}
          end
        }
      end

      rule argument
        var space "as" space expression
      end

      rule function
        "function" space name:var space "uses" space arg:var remaining_args:(space "," space arg:var)* space newline
          body:(expression space newline)*
        "end" <Function>
      end

      rule equation
        object space op:[\+\-\/\*] space expression <Equation>
      end

      rule assignment
        "set" space var space "to" !"to" space expression <Assignment>
      end

      rule keyword
        "set" / "end" / "function" / "repeat" / "with" / "as" / "to" / "uses" / "times" / "if" / "else" / "while" / "and" / "or" / "true" / "false"
      end

      rule var
        !keyword [a-zA-Z] [\w]* <Variable>
      end

      rule comment
        '#' (!newline .)+ (newline / !.)
      end

      rule space
        [ \t]*
      end

      rule newline
        space ("\r\n"+ / [\r\n]+) space
      end
    end

  end
end
